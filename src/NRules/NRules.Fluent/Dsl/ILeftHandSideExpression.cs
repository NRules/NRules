using System;
using System.Linq.Expressions;

namespace NRules.Fluent.Dsl;

/// <summary>
/// Rule's left-hand side (conditions) expression builder.
/// </summary>
public interface ILeftHandSideExpression
{
    /// <summary>
    /// Defines a pattern for facts matching a set of conditions.
    /// Binds matching fact to a variable.
    /// </summary>
    /// <typeparam name="TFact">Type of fact to match.</typeparam>
    /// <param name="alias">Alias for the matching fact.</param>
    /// <param name="conditions">Set of conditions the fact must satisfy to trigger the rule.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression Match<TFact>(Expression<Func<TFact>> alias, params Expression<Func<TFact, bool>>[] conditions)
        where TFact : notnull;

    /// <summary>
    /// Defines a pattern for facts matching a set of conditions.
    /// Does not bind matching fact to a variable. Optionally, enables aggregation of matching facts.
    /// </summary>
    /// <param name="conditions">Set of additional conditions the fact must satisfy to trigger the rule.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression Match<TFact>(params Expression<Func<TFact, bool>>[] conditions)
        where TFact : notnull;

    /// <summary>
    /// Defines a pattern that triggers the rule only if there is at least one matching fact (existential quantifier).
    /// </summary>
    /// <typeparam name="TFact">Type of fact to match.</typeparam>
    /// <param name="conditions">Set of conditions the facts must satisfy to trigger the rule.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression Exists<TFact>(params Expression<Func<TFact, bool>>[] conditions)
        where TFact : notnull;

    /// <summary>
    /// Defines a pattern that triggers the rule only if there are no matching facts (negation quantifier).
    /// </summary>
    /// <typeparam name="TFact">Type of fact to match.</typeparam>
    /// <param name="conditions">Set of conditions the facts must not satisfy to trigger the rule.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression Not<TFact>(params Expression<Func<TFact, bool>>[] conditions)
        where TFact : notnull;

    /// <summary>
    /// Defines a pattern that triggers the rule only if all facts that match the base condition
    /// also match all the remaining conditions (universal quantifier).
    /// </summary>
    /// <typeparam name="TFact">Type of fact to match.</typeparam>
    /// <param name="baseCondition">Base condition that filters the facts to match the remaining conditions.</param>
    /// <param name="conditions">Set of additional conditions that all matching facts must satisfy to trigger the rule.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression All<TFact>(Expression<Func<TFact, bool>> baseCondition, params Expression<Func<TFact, bool>>[] conditions)
        where TFact : notnull;

    /// <summary>
    /// Defines a pattern that triggers the rule only if all facts of a given type match the condition.
    /// </summary>
    /// <typeparam name="TFact">Type of fact to match.</typeparam>
    /// <param name="condition">Condition that all facts of a given type must satisfy to trigger the rule.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression All<TFact>(Expression<Func<TFact, bool>> condition)
        where TFact : notnull;

    /// <summary>
    /// Queries rules engine for matching facts.
    /// </summary>
    /// <typeparam name="TResult">Query result type.</typeparam>
    /// <param name="alias">Alias for the query results.</param>
    /// <param name="queryExpression">Query expression.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression Query<TResult>(Expression<Func<TResult>> alias, Func<IQuery, IQuery<TResult>> queryExpression)
        where TResult : notnull;

    /// <summary>
    /// Defines a group of patterns joined by an AND operator.
    /// If all of the patterns in the group match then the whole group matches.
    /// </summary>
    /// <param name="builder">Group expression builder.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression And(Action<ILeftHandSideExpression> builder);

    /// <summary>
    /// Defines a group of patterns joined by an OR operator.
    /// If either of the patterns in the group matches then the whole group matches.
    /// </summary>
    /// <param name="builder">Group expression builder.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression Or(Action<ILeftHandSideExpression> builder);

    /// <summary>
    /// Binds expression to a variable. Expression can use previously defined rule patterns.
    /// </summary>
    /// <typeparam name="TResult">Type of the expression result.</typeparam>
    /// <param name="alias">Alias for the expression.</param>
    /// <param name="expression">Expression to bind.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression Let<TResult>(Expression<Func<TResult>> alias, Expression<Func<TResult>> expression);

    /// <summary>
    /// Adds match conditions to existing rule patterns.
    /// </summary>
    /// <param name="conditions">Additional match conditions.</param>
    /// <returns>Left hand side expression builder.</returns>
    ILeftHandSideExpression Having(params Expression<Func<bool>>[] conditions);
}
